<h2>Step-1</h2>
<div class="answer"> <p>One way to ensure that circular wait should hold is to impose a total ordering of all resources types and to require that each process request resource in an increasing order of enumeration. </p> <p> Let R= {R<sub>1</sub>, R<sub>2</sub>, . . . ,R<sub>m</sub>} be the set of resource types. Each resource type is assigned a unique number which is of type integer. It allows us to compare two resources and to determine whether one precedes another in our ordering. </p> <p> <img src="https://media.cheggcdn.com/study/3ac/3ac73f94-f408-41a3-8642-c8e67be1589b/300-7-3e-i1.png" /> is one-to-one function, N is a set of natural numbers. </p> <p>To have no circular wait.</p> <p>One must have <img src="https://media.cheggcdn.com/study/5c3/5c35f782-b25f-4401-b7df-a8d53149f216/300-7-3e-i2.png" /></p> <p> <img src="https://media.cheggcdn.com/study/083/0839a374-51d9-4212-970b-0971a189493c/300-7-3e-i3.png" /> </p> <p>By the transitivity rule <img src="https://media.cheggcdn.com/study/cee/cee7b212-2efd-4abe-b2a3-f03adddb1e2e/300-7-3e-i4.png" /></p> <p>is impossible. Hence no circular wait. But in containment. Whenever a thread acquire the lock for object A,B, C, D, E it must first acquire lock for another object F.</p> <p> <img src="https://media.cheggcdn.com/study/4fd/4fd36df9-7d36-4541-9a80-faba64ae960e/300-7-3e-i5.png" /> is in deadlock.</p> <p> <img src="https://media.cheggcdn.com/study/3b1/3b1c141e-4f85-4cae-aa82-1535b7112568/300-7-3e-i6.png" /> not in deadlock.</p> <p>i.e. if any two thread will be in dead lock than sixth thread will be in to avoid the dead lock. That is object F can occur and be acquiring a lock whenever a deadlock is to occur.</p></div>
