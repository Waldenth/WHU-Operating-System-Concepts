<h2>Step-1</h2>
<div class="answer"> <p>Refer to the code provided in Figure 7.4 of chapter 7 of the textbook for complete code.</p> </div>
<h2>Step-2</h2>
<div class="answer"> <p> <b>Occurrence of deadlock by the CPU scheduler: </b>There are four necessary conditions that must hold for a deadlock to occur. They are as follows:</p> <p>• Mutual exclusion – At least one resource must be in non-shareable mode.</p> <p>• No-preemption – The resources can only be released voluntarily by the process.</p> <p>• Hold and wait – A process must be holding at least 1 resource and should be waiting for another resource held by another process.</p> <p>• Circular wait – In a set of processes {P1, P2…..Pn} there must exist waiting between them such that process P1 is waiting for the resource held by process P2 and so on.</p> </div>
<h2>Step-3</h2>
<div class="answer"> <p>The function of CPU schedular is to select the process ready to execute and allocate them CPU.</p> <p>The code given in Figure 7.4 uses two thread requesting for same process “first_mutex” and “second_mutex” but in different order. The work of CPU scheduler here is to provide CPU to the process which is ready for execution. </p> <p>• Suppose, there is a situation that in do_work_one function, only one statement that is first_mutex, gets acquired but second_mutex is not acquired by do_work_one function. </p> <p>• Now, after acquiring of the first_mutex CPU scheduler will give control to do_work_two function. In do_work_two function the first statement gets executed and it is seen that the second_mutex is not acquired at the moment. So, do_work_two function acquired the second_mutex. </p> <p>• Now, when second statement of any function gets executed, then the statement needs to wait for the other mutex.</p> <p>• This is because second statement of do_work_one function requires second_mutex which is currently held by do_work_two function. </p> <p>• Similarly, second statement of do_work_two function requires first_mutex which is being held by do_work_one function. </p> <p>• In this way, both of the functions enters the waiting state and deadlock occurs.</p> </div>
<h2>Step-4</h2>
<div class="answer"> <p> <b>Contribution of CPU scheduler for deadlock:</b> </p> <p>• The role of CPU scheduler in the given program is to provide CPU to the thread that is ready for execution.</p> <p>• A CPU scheduler uses many algorithms to do so like giving fix time slot to a thread (pre-emption). </p> <p>• Suppose, there is a situation that in do_work_one function, the first statement gets executed and the CPU scheduler gives the CPU time to do_work_two function.</p> <p>• The do_work_two function will hold second_mutex while waiting for first_mutex while the do_work_one function is holding the first_mutex and waiting for second_mutex to be free. </p> <p>• In this case, there will be a deadlock as both the threads are holding a mutex and requesting for another mutex.</p> <p> <b>Hence, this way CPU scheduler can contribute in deadlock process.</b> </p></div>
