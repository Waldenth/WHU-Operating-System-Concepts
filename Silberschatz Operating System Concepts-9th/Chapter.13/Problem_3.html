<h2>Step-1</h2>
<div class="answer"> <p>2481-13-4E SA: 8683</p> <p> SR: 4578</p> <p>________________________________________________________________________</p> <p> Polling I/O can be very fast and efficient than interrupt-driven I/O, if both the device and the controller are fast and if there is significant data to transfer. It becomes inefficient, when it is attempted repeatedly, yet rarely finds a device to be ready for service, while other useful CPU processing remains undone. </p> <p> A <b>single serial port</b> will perform I/O relatively slow and has small buffer thereby host waits too long before returning to read the bytes. So, we use <b>Interrupt-driven I/O </b>which has hardware controller to notify the CPU when the device becomes ready for service, rather than to require the CPU to poll repeatedly for an I/O completion. In the meantime CPU will switch to another task, and it will be notified when the device becomes idle. </p> <p> But in case of <b>front-end processor</b> such as terminal concentrator can produce a lot of short I/O operations, and interrupting for each one could create a heavy load on the system. So, a well-timed polling loop could reduce that load without wasting many resources through looping with no I/O needed. So, we would use <b>polling I/O</b> in this case.</p></div>
