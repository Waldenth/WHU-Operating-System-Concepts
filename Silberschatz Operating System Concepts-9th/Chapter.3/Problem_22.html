<h2>Step-1</h2>
<div class="answer"> <p> <b>Program Plan:</b> </p> <p>• Make a function shm_allocate to allocate a shared memory segment.</p> <p>• Create a child process and check that the child executed normally.</p> <p>• Print out the contents of the shared memory.</p> <p>• Release the shared memory object using shm_release function.</p> </div>
<h2>Step-2</h2>
<div class="answer"> <p> <b>Program:</b> </p> <p>//Include the header files for performing the operations.</p> <p>#include <stdio.h></p> <p>#include <sys/mman.h></p> <p>#include <sys/stat.h></p> <p>#include <sys/types.h></p> <p>#include <sys/wait.h></p> <p>#include <fcntl.h></p> <p>#include <unistd.h></p> <p>#include <stdlib.h></p> <p>#include <errno.h></p> <p>Initialize a variable name as const for shared memory segment, then initialized increment size in shared memory segment in variable size.</p> <p>// The name of the shared memory segment</p> <p>const char <b>*</b>NAME <b>=</b> "/13258-3-22PP"<b>;</b></p> <p>// The size by which to increment the size</p> <p>// of the shared memory segment</p> <p>const size_t SIZE <b>=</b> 4096<b>;</b></p> <p>// The size of the shared memory segment</p> <p>static size_t s_size <b>=</b> 0<b>;</b></p> <p>In shm_allocate function, create a shared memory object and shared memory segment.</p> <p>//Allocate a shared memory segment </p> <p>static int shm_allocate<b>(</b>size_t size<b>,</b> int <b>*</b>pshm_fd<b>,</b></p> <p> void <b>**</b>pptr<b>)</b></p> <p> <b>{</b> </p> <p> <b>if</b> <b>(!</b>pshm_fd <b>||</b> <b>!</b>pptr<b>)</b></p> <p> <b>return</b> <b>-</b>1<b>;</b> </p> <p> // Set the ptr to shared memory to an invalid value</p> <p> <b>*</b>pptr <b>=</b> MAP_FAILED<b>;</b></p> <p> // Create a shared memory object</p> <p> <b>*</b>pshm_fd <b>=</b> shm_open<b>(</b>NAME<b>,</b> O_CREAT <b>|</b> O_RDWR<b>,</b> 0666<b>);</b></p> <p> <b>if</b> <b>(*</b>pshm_fd <b><</b> 0<b>)</b></p> <p> <b>return</b> <b>-</b>2<b>;</b></p> <p> // Set the size of the shared memory object</p> <p> <b>if</b> <b>(</b>ftruncate<b>(*</b>pshm_fd<b>,</b> size<b>)</b> <b><</b> 0<b>)</b></p> <p> <b>return</b> <b>-</b>3<b>;</b></p> <p> // Create a shared memory segment</p> <p> <b>*</b>pptr <b>=</b> mmap<b>(</b><b>NULL</b><b>,</b> size<b>,</b> PROT_WRITE <b>|</b> PROT_READ<b>,</b></p> <p> MAP_SHARED<b>,</b> <b>*</b>pshm_fd<b>,</b> 0<b>);</b></p> <p> <b>if</b> <b>(*</b>pptr <b>==</b> MAP_FAILED<b>)</b></p> <p> <b>return</b> <b>-</b>4<b>;</b></p> <p> <b>return</b> 0<b>;</b></p> <p> <b>}</b> </p> <p>Use shm_release function to unmap the shared memory segment and unlink the shared memory segment.</p> <p>//Release a shared memory segment and object </p> <p> </p> <p>static void shm_release<b>(</b>size_t size<b>,</b> int shm_fd<b>,</b></p> <p> void <b>*</b>ptr<b>)</b></p> <p> <b>{</b> </p> <p> // Unmap the shared memory segment</p> <p> <b>if</b> <b>(</b>ptr <b>!=</b> MAP_FAILED<b>)</b></p> <p> munmap<b>(</b>ptr<b>,</b> size<b>);</b></p> <p> // Unlink the shared memory segment</p> <p> <b>if</b> <b>(</b>shm_fd <b>>=</b> 0<b>)</b></p> <p> shm_unlink<b>(</b>NAME<b>);</b></p> <p> <b>}</b> </p> <p>//The startup function </p> <p>int main<b>(</b>int argc<b>,</b> char <b>**</b>argv<b>)</b></p> <p> <b>{</b> </p> <p> int n<b>;</b></p> <p> int status<b>;</b></p> <p> // Check that a positive integer was passed</p> <p> <b>if</b> <b>(</b>argc <b>!=</b> 2<b>)</b> <b>{</b></p> <p> fprintf<b>(</b>stderr<b>,</b> "%s [+ve integer]\n"<b>,</b> <b>*</b>argv<b>);</b></p> <p> <b>return</b> 1<b>;</b></p> <p> <b>}</b></p> <p> // Set n to the argument the program was invoked with</p> <p> n <b>=</b> atoi<b>(</b>argv<b>[</b>1<b>]);</b></p> <p> <b>if</b> <b>(</b>n <b><=</b> 0<b>)</b> <b>{</b></p> <p> fprintf<b>(</b>stderr<b>,</b> "%s [+ve integer]\n"<b>,</b> <b>*</b>argv<b>);</b></p> <p> <b>return</b> 2<b>;</b></p> <p> <b>}</b></p> <p> <b>do</b> <b>{</b></p> <p> s_size <b>+=</b> SIZE<b>;</b></p> <p> // The file descriptor of the shared memory object</p> <p> </div>
<h2>Step-3</h2>
<div class="answer"> int shm_fd<b>;</b></p> <p> // Pointer to the shared memory</p> <p> void <b>*</b>ptr<b>;</b></p> <p> // Allocate the shared memory</p> <p> <b>if</b> <b>(</b>shm_allocate<b>(</b>s_size<b>,</b> <b>&</b>shm_fd<b>,</b> <b>&</b>ptr<b>)</b> <b><</b> 0<b>)</b> <b>{</b></p> <p> fprintf<b>(</b>stderr<b>,</b> "Couldn't allocate "</p> <p> "shared memory of size %lu "</p> <p> "bytes\n"<b>,</b> s_size<b>);</b></p> <p> <b>return</b> 3<b>;</b></p> <p> <b>}</b></p> <p>Fork process is called and process id is stored in variable pid. If pid is greater than zero than wait for child to execute. </p> <p> // Fork off a child process</p> <p> pid_t pid <b>=</b> fork<b>();</b></p> <p> // Is is the parent process?</p> <p> <b>if</b> <b>(</b>pid <b>></b> 0<b>)</b> <b>{</b></p> <p> // Wait for the child to exit</p> <p> wait<b>(&</b>status<b>);</b></p> <p> <b>}</b></p> <p> // Is it the child process?</p> <p> <b>else</b> <b>if</b> <b>(</b>pid <b>==</b> 0<b>)</b> <b>{</b></p> <p> int out<b>;</b></p> <p> // While n is greater than 1</p> <p> <b>while</b> <b>(</b>n <b>></b> 1<b>)</b> <b>{</b></p> <p> // Print n to the shared memory</p> <p> out <b>=</b> snprintf<b>(</b>ptr<b>,</b> s_size<b>,</b> "%d\n"<b>,</b> n<b>);</b></p> <p> // Did we run out of space?</p> <p> <b>if</b> <b>(</b>out <b>>=</b> s_size<b>)</b></p> <p> <b>return</b> 1<b>;</b></p> <p> // Decrement size</p> <p> s_size <b>-=</b> out<b>;</b></p> <p> // Increment the pointer into</p> <p> // the shared memory</p> <p> ptr <b>+=</b> out<b>;</b></p> <p> // Apply the Collatz conjecture</p> <p> n <b>=</b> <b>(</b>n <b>%</b> 2<b>)</b> <b>?</b> 3 <b>*</b> n <b>+</b> 1 <b>:</b> n <b>/</b> 2<b>;</b></p> <p> <b>}</b></p> <p> // Print out the final value of n</p> <p> // to the shared memory</p> <p> out <b>=</b> snprintf<b>(</b>ptr<b>,</b> s_size<b>,</b> "%d\n"<b>,</b> n<b>);</b></p> <p> // Return 1 if we ran out of space,</p> <p> // else return zero</p> <p> <b>return</b> <b>(</b>out <b>>=</b> s_size<b>)</b> <b>?</b> 1 <b>:</b> 0<b>;</b></p> <p> <b>}</b></p> <p> // Did the fork system call not work?</p> <p> <b>else</b> <b>if</b> <b>(</b>pid <b><</b> 0<b>)</b> <b>{</b></p> <p> fprintf<b>(</b>stderr<b>,</b> "fork blew %d\n"<b>,</b> errno<b>);</b></p> <p> // Release the shared memory and exit</p> <p> shm_release<b>(</b>s_size<b>,</b> shm_fd<b>,</b> ptr<b>);</b></p> <p> <b>return</b> 4<b>;</b></p> <p> <b>}</b></p> <p> // Check that the child exicuted normally</p> <p> <b>if</b> <b>(!</b>WIFEXITED<b>(</b>status<b>))</b> <b>{</b></p> <p> fputs<b>(</b>"Child did not exit normally"<b>,</b> stderr<b>);</b></p> <p> // Was it killed by a signal?</p> <p> <b>if</b> <b>(</b>WIFSIGNALED<b>(</b>status<b>))</b></p> <p> fprintf<b>(</b>stderr<b>,</b> ", it was terminated by "</p> <p> "signal %d"<b>,</b> WTERMSIG<b>(</b>status<b>));</b></p> <p> fputc<b>(</b>'\n'<b>,</b> stderr<b>);</b></p> <p> // Release the shared memory</p> <p> shm_release<b>(</b>s_size<b>,</b> shm_fd<b>,</b> ptr<b>);</b></p> <p> <b>return</b> 5<b>;</b></p> <p> <b>}</b></p> <p> // Did the child exit with a value of zero?</p> <p> <b>else</b> <b>if</b> <b>(</b>WEXITSTATUS<b>(</b>status<b>)</b> <b>==</b> 0<b>)</b></p> <p> // Print out the contents of the shared memory</p> <p> fputs<b>(</b>ptr<b>,</b> stdout<b>);</b></p> <p> // Release the shared memory</p> <p> shm_release<b>(</b>s_size<b>,</b> shm_fd<b>,</b> ptr<b>);</b></p> <p> <b>}</b></p> <p> // Loop while the child did not exit</p> <p> // with a valid value</p> <p> <b>while</b> <b>(</b>WEXITSTATUS<b>(</b>status<b>)</b> <b>></b> 0<b>);</b></p> <p> <b>return</b> 0<b>;</b></p> <p> <b>}</b> </p> </div>
<h2>Step-4</h2>
<div class="answer"> <p> <b>Sample Output:</b> </p> <p>21:32 3$ ./3-22PP 35</p> <p>35</p> <p>106</p> <p>53</p> <p>160</p> <p>80</p> <p>40</p> <p>20</p> <p>10</p> <p>5</p> <p>16</p> <p>8</p> <p>4</p> <p>2</p> <p>1</p></div>
