<h2>Step-1</h2>
<div class="answer"> <p> <b>a)</b> </p> <p>• When a process first starts execution in a system that uses pure demand paging, the page fault rate is very high, and it will be<b> 100%</b>. </p> <p>• At the starting of the execution of a process, the memory does not contain any pages. Each page reference will lead to page fault until all the pages that are required for execution will load into the memory.</p> </div>
<h2>Step-2</h2>
<div class="answer"> <p> <b>b)</b> </p> <p>Once the working set for a process is loaded into memory, the page fault rate will be <b>0%</b> because the all the pages required for current execution are loaded into the memory. </p> </div>
<h2>Step-3</h2>
<div class="answer"> <p> <b>c)</b> </p> <p>If a process changes its locality and the size of the new working set is too large to be stored in available free memory, then the designers handles this situation by allowing operating system to suspend one of the process. </p> <p>The other options to handle this system are:</p> <p>• The process pages are written out (swapped), and its frames are allocated to the new process and the suspended process can be restarted later. </p> <p>• This strategy prevents thrashing while keeping the degree of multiprogramming as high as possible. </p> <p>• Thus, it optimizes the CPU utilization. </p></div>
