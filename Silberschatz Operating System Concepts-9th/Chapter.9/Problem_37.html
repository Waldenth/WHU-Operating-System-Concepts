<h2>Step-1</h2>
<div class="answer"> <p> <b>slab allocator</b> </p> <p>• The slab allocator is introduced with the idea of using a separate cache for each different object type. For example, allocator uses one cache to store all file objects, one cache to store process descriptor objectors and another cache to store semaphore objects etc. </p> <p>• If there is no such object based allocator, the kernel spends lot of its time allocating, initializing and destroying objects.</p> <p>• The slab allocator maintains a variable number of caches per each object type. Each cache contains one or more blocks of contiguous pages in memory called slabs which are used to store objects. </p> </div>
<h2>Step-2</h2>
<div class="answer"> <p> <b>Problem with using one cache per object type</b> </p> <p>• Assume system maintaining one cache per object type. Then the system does not provide good scalability with multiple CPUs, as global slab cache must be locked while it is being accessed. </p> <p>• For example, if two processes want to allocate file objects from file objects cache. Then allocation request of first process should hold a lock on the file object cache and allocation request of second block must be blocked until the file object of first process is allocated. </p> <p>• Thus, cache accesses must be serialized on multiprocessor systems. This will reduce the efficiency of the allocator. </p> <p> <b>Solution to scalability issue</b> </p> <p>• Solaris addressed the scalability problem by implementing slab allocator with several internal layers. </p> <p>• These additional layers give a cache, called per-CPU object cache, for each CPU. That is, each CPU has its own cache of objects. </p> <p>• Thus, without holding a lock on global cache , a process can store its object from local per-CPU object cache. </p></div>
