<h2>Step-1</h2>
<div class="answer"> <p>2481-9-16E SA: 8683</p> <p> SR: 4478</p> <p>________________________________________________________________________</p> <p> <b>a.) 5,000 page faults, </b>because the program text will never be the least recently used page, since program instructions are run between any two assignments to the array. Therefore, we can ignore the program and consider only the 2 physical pages for the data. The book assumes that matrices are stored in row-major order. In initialization loop of (a), the row index ‘<i>i’</i> is incremented in the inner loop, while the column index is incremented in the outer loop. As a result, each increment of the inner loop skips half of the page size by skipping to the same column position within the next row. Thus, a new page is referenced every two times around the inner loop. The number of rows is large enough that no data page will still be one of the two in memory when it is touched again, so every second page reference generates a page fault. <b>Since the array A has 10,000 elements, this leads to a total of 5,000 page faults</b>, since every other array reference will visit a data page that is not one of the 2 currently in memory. </p> </div>
<h2>Step-2</h2>
<div class="answer"> <p> <b>b.) 50 page faults</b>, because the initialization loop of (b), the page holding the program will also never be paged out, for the same reason as in (a). So, once again, we can assume 2 physical pages for the matrix data. In this case, the inner loop increments ‘<i>j’</i> and thus visits every member of a row before visiting the next. Thus, each page is entirely initialized and then never touched again. So there is exactly one page fault per page holding the array. Since the <b>array has 10,000 elements and the page size is 200, there will be 10,000 / 200 = 50 page faults. </b></p></div>
