<h2>Step-1</h2>
<div class="answer"> <p> <b>Cache Manager</b> </p> <p>Windows manages cache memory and its working through a centralized facility known as Cache Manager, instead of a file system to maintain caching. All the components under the I/O Manager utilize the Cache Manager along with The Virtual Memory Manager to handle the flow of the process task.</p> The process flow between the I/O manager, VM manager, and Cache manager is as shown below: </div>
<h2>Step-2</h2>
<div class="answer"> <img src="https://media.cheggcdn.com/study/274/2742a754-ee28-43c4-8b66-7103a30a4309/5644-22-19E-i1.png" alt="5644-22-19E" /> </div>
<h2>Step-3</h2>
<div class="answer"> <p>Windows Cache Manager is based on caching files instead of caching raw memory blocks. The cache size is managed dynamically according to the free memory available. The files are mapped into Kernel Memory by the cache memory manager and a special interface is accessible to the Virtual Memory Manager for creating a private working set.</p> <p>Each block of a cache is of 256KB, having its own virtual address control block (VACB). This VACB is used to store to file offset and the virtual address linked to the cache along with the count of processes using the cache block. Cache Manager maintains a dynamic array for handling VACB.</p> <p>When a user level read request is sent to the I/O manager for a file, an IRP is send by the I/O manager to look, for the file residence volume, from the I/O Stack. Cache manager is called by the file system, if the requested file is marked as cacheable, to look for the data in cache file views. The entry for the file in the VACB array either provides the byte offset or returns invalid. A new memory block is reserved and an entry made in the VACB array if return value was invalid. The cache buffer is then used to make a copy of the data for the mapped file.</p> <p>If frequent requests are made for the same data, then for such records the cache manager looks for access pattern. If a record is found in last three requests the data is pre-fetched before the next request for the same application/file is made. This saves the disk I/O to execute the cache process.</p></div>
