<h2>Step-1</h2>
<div class="answer"> <p>Wait (mutex);</p> <p>------</p> <p>body of F</p> <p> --- - - - </p> <p>if (next – count >0)</p> <p>signal (next);</p> <p>else</p> <p>signal (mutex);</p> <p>Mutual exclusion within a monitor is ensured.</p> <p>Operation x. signal ( ) can be implemented as </p> <p>if (x – count >0)</p> <p>{ next – count ++;</p> <p>Signal (x – sem);</p> <p>Wait (next);</p> <p>Next _ count -- -- ;</p> <p>}</p> <p> When a thread T1 calls signal(), the control switches to another thread T2 that is waiting for the condition immediately. In Hoare's implementation, when T2 leaves the monitor or calls another wait(), the control should be switched back to T1,  not to the other threads that are waiting to get into the monitor. Since T1 is still inside the monitor, although it is inactive now, it would be better to let T1 finish its work first than admit the others into the monitor. The next semaphore and the next_count variable are used to keep track of this situation. </p> <p>If signal() is the last statement of every monitor procedure, we are ensured that T1 is no longer in the monitor and therefore we do not need next semaphore and the next_count variable anymore. </p></div>
