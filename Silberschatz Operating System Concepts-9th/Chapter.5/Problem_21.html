<h2>Step-1</h2>
<div class="answer"> <p> <b>Solution:</b> </p> <p> <b>Semaphores are defined as inter-pr</b> <b>ocess communication.</b> </p> <p>• It is used to control and monitor the open socket connections.</p> <p>• It allows the process to create the open socket connections that communicate with the other processes.</p> <p>• It describes the open connection’s existence and properties among the sockets.</p> <p>• The server deals with each connection via semaphore communication, it instructs new connections are done until the limit is reached.</p> <p>• It makes the individual processes to exit to make a way to new connections.</p> <p> <b>A semaphore is initialized with open socket connections, the number of allowable connections is made.</b> </p> <p> <b>Here, </b> </p> <p>• the acquire() function is called if the connection is accepted.</p> <p>• the release() function is called if the connection is released.</p> <p>• The repeated number of calls to acquire() will block the existing connection, where the number of allowable socket connections to the system is reached.</p> <p>• The release() method is invoked where the existing connection is terminated.</p> </div>
<h2>Step-2</h2>
<div class="answer"> <p> <b>Process:</b> </p> <p>Initialize the semaphore so its value is N. </p> <p>• When a connection comes in, wait on the semaphore. </p> <p>• When a connection is released, signal the semaphore.</p> <p> <b>Semaphore operations are defined as </b> </p> <p>S=N;</p> <p>acquire (s)</p> <p>{</p> <p>val--;</p> <p>if(val<0)</p> <p>{</p> <p>//add the process to the list</p> <p>block;</p> <p>}</p> <p>}</p> <p>release(S)</p> <p>{</p> <p>val++;</p> <p>if(val<=0)</p> <p>{</p> <p>//remove the process p from the list</p> <p>wake_up(p);</p> <p>}</p> <p>}</p> </div>
<h2>Step-3</h2>
<div class="answer"> <p> <b>The main disadvantage of mutual exclusion is that they require all process to be busy waiting. </b> </p> <p>• Busy waiting degrades the CPU cycles, it leads other process does not use it. </p> <p>• A semaphore that gives the result “spin” is called spin lock while the process will be waiting for a lock situation.</p> <p>• The main advantage of the spin lock is, when the process must wait on a lock situation and the context switch takes much time.</p> <p>• Therefore, no context switch is required</p> <p>• Hence spin lock is useful for short locks. </p> <p>• They are often used in multi-processor system where one thread spin while another thread performs its critical section. </p> <p> <b>The process instead of busy waiting, it will block itself, it places the process into the waiting queue. </b> </p> <p>• Then, the process is switched to the waiting queue state with the association of semaphore.</p> <p>• Then the CPU scheduler schedules another process to execute where the control is transferred to it.</p> <p>• It restarts the process and transferred to the ready queue for the process execution. </p> <p>• Depends on the CPU scheduling algorithm, the CPU switches between the running process to the ready process possibly.</p> <p> <b>Semaphore </b> </p> <p> <img src="https://media.cheggcdn.com/study/5e3/5e3afee5-bfd9-4812-a3cc-de438f2b9b4b/13258-5-21E-i1.png" /> </p></div>
