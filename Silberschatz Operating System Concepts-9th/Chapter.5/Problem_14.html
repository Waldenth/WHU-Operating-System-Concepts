<h2>Step-1</h2>
<div class="answer"> <p>Consider the following piece of code to illustrate how a compare_and_swap () instruction helps in achieving mutual exclusion under bounded-waiting policies.</p> <p> <b>Bounded-waiting mutual exclusion with </b> <b>compare_and_swap():</b> </p> <p> <img src="https://media.cheggcdn.com/media/f9a/f9aaffd6-73b4-4e45-b401-97c3a7708a15/13258-5-14E-i1.png" alt="Picture 1" /> </p> </div>
<h2>Step-2</h2>
<div class="answer"> <p> <b>EXPLANATION:</b> </p> <p>Here, variable key is local to “P<sub>k</sub>” process. The entire code goes on with two main shared variables, both taken as Booleans:</p> <p>• lock</p> <p>• waiting [ n ]</p> <p>Both the Boolean variables are initialized to FALSE, for all ongoing processes that is “P<sub>k</sub>”; where k = 0 to n-1 values. </p> <p> <b>According to the above code:</b> </p> <p>If lock = FALSE<b> ,</b> no upcoming processes are in critical section. Whereas, if waiting[k] = FALSE is achieved P<sub>k</sub> process not ready to enter into its critical section.</p> <p>• According to Bounded Waiting, after a request is generated by a process to get into its critical section and before granting the request, there exist the limit on number of times other process are approved to get into its critical section.</p> <p>• Bounded-waiting cannot be satisfied by the basic synchronization instructions available for hardware components. </p> <p>• But the instructions available can be modified into a new program which satisfies the condition of bounded-waiting.</p></div>
