<h2>Step-1</h2>
<div class="answer"> <p> <b>Implementation:</b> </p> <p>• The algorithm in the bounded-buffer problem will copy the production value into the monitor’s local buffer and again copies it back to the consumer from the monitor’s local buffer.</p> <p>• By the algorithm, with the usage of these copy operations will increase the cost of the system.</p> <p>• The increased cost will lead to the decrease in the throughput of the system.</p> <p>• The problem can be minimized by using buffer portions and by storing pointers in the system.</p> <p>• Also, it is easy to modify the code and to store the pointer in the buffer region from out of the monitor’s state.</p> <p>• Thereby, it is less costly and less expensive that the operations can be held shorter.</p> <p>• <b>Therefore, it will increase the throughput of the monitor</b>.</p> </div>
<h2>Step-2</h2>
<div class="answer"> <p> <b>Algorithm for a bounded-buffer monitor:</b> </p> <p>//Implementation of Monitor</p> <p>Monitor</p> <p>{</p> <p> //condition to check full or empty</p> <p> Condition full, empty;</p> <p> //create a Queue</p> <p> Queue q;</p> <p> //Insert the items in the list</p> <p> BbInsert(item)</p> <p> {</p> <p> //use while() loop to check </p> <p> //whether the queue is full or empty</p> <p> while (queue.isFull())</p> <p> //if queue is full, wait for the release</p> <p> full.wait();</p> <p> //insert a item</p> <p> q.insert(item);</p> <p> //release the queue </p> <p> //make it empty</p> <p> empty.release();</p> <p> }</p> <p> </p> <p> //Remove the items in the list</p> <p> item BbRemove()</p> <p> {</p> <p> //use while() loop to check </p> <p> //whether the queue is full or empty</p> <p> while (queue.isEmpty())</p> <p> //if queue is empty, wait for the insertion</p> <p> empty.wait();</p> <p> //remove the item in the queue</p> <p> result = q.remove();</p> <p> //release the queue</p> <p> //make it full</p> <p> full.release();</p> <p> return result;</p> <p> }</p> <p>}//end the Monitor</p> </div>
<h2>Step-3</h2>
<div class="answer"> <p> <b>Algorithm for a bounded-buffer monitor with the producer-consumer relation:</b> </p> <p>//Implementation of Monitor bounded buffer</p> <p>monitor bounded buffer</p> <p>{</p> <p> //declare the items </p> <p> //in the integer variables as array</p> <p> int items[MAX ITEMS];</p> <p> //declare the numItems as 0</p> <p> int numItems = 0;</p> <p> //condition to check full or empty</p> <p> condition full, empty;</p> <p> </p> <p> //Create a method produce</p> <p> //with the argument v</p> <p> void produce(int v)</p> <p> {</p> <p> //use while() loop to check </p> <p> //whether the numItems</p> <p> //is equal to Max ITEMS</p> <p> while (numItems == MAX ITEMS) </p> <p> //if queue is full, wait for the release</p> <p> full.wait();</p> <p> //increment the numItems and declared in v</p> <p> items[numItems++] = v;</p> <p> //release the signal</p> <p> //make it empty</p> <p> empty.signal();</p> <p> }</p> <p> </p> <p> //Create a method consume</p> <p> int consume()</p> <p> {</p> <p> //declare the variable retVal</p> <p> //in the integer</p> <p> int retVal;</p> <p> //use while() loop to check </p> <p> </div>
<h2>Step-4</h2>
<div class="answer"> //whether the numItems</p> <p> //is equal to 0</p> <p> while (numItems == 0) </p> <p> //if queue is empty, wait for the insertion</p> <p> empty.wait();</p> <p> //decrement the numItems and declared in retVal</p> <p> retVal = items[--numItems];</p> <p> //release the signal</p> <p> //make it full</p> <p> full.signal();</p> <p> //return the value retVal</p> <p> return retVal;</p> <p> }</p> <p>}</p></div>
