<h2>Step-1</h2>
<div class="answer"> <p>R<b>ace condition </b>is the scenario where many processes retrieve and modify the same data simultaneously and outcome of the program is based on the sequence in which they are accessed.</p> </div>
<h2>Step-2</h2>
<div class="answer"> <p> <b>a.</b> </p> <p>• The given code illustrates the presence of one race condition; that is on the variable number_of_processes. </p> <p>• The function fork() checks and increments the variable number_of_processes while; the exit()decrements the variable number_of_processes.</p> <p>• Thus, both update the contents of the variable number_of_processes. </p> <p>• The variable can be modified by the processes of fork() and exit() simultaneously and will result in inconsistencies due to the race condition occurring among various processes.</p> <p>• Therefore, the final value of number_of_processes depends upon the process execution order.</p> </div>
<h2>Step-3</h2>
<div class="answer"> <p> <b>b.</b> </p> <p>• To prevent the race condition, the mutex lock with acquire() and release() operations can be placed at the beginning and end of a critical section in both the fork() and exit() functions. </p> <p>• In the fork() function’s allocate_process(),the acquire()should be placed before the test condition while, release() should be placed after incrementing the variable number_of_processes. </p> <p>• In the exit() function’s release_process()the acquire()should be placed before the decrement of the variable number_of_processes while; release() should be placed after the decrement of the variable number_of_processes.</p> <p>• The updated code snippet is:</p> <p>int allocate_process()</p> <p>{</p> <p> int new_pid;</p> <p> <b> acquire();</b> </p> <p> if(number_of_processes==MAX_PROCESSES)</p> <p> return -1;</p> <p> else{</p> <p> ++ number_of_processes;</p> <p> <b> release();</b> </p> <p> return new_pid;</p> <p>}</p> <p>void release_process(){</p> <p> <b> acquire();</b> </p> <p> -- number_of_processes;</p> <p> <b> release();</b> </p> <p>}</p> </div>
<h2>Step-4</h2>
<div class="answer"> <p> <b>c.</b> </p> <p>• All the operations on atomic_t variable are atomic i.e. they execute within one clock cycle.</p> <p>• If the variable number_of_processes is made atomic_t, the increment and decrement operations on the variable will become atomic but the race condition can still occur in the allocate_process() function.</p> <p>• This is because the value of number_of_processes is initially tested in the if-condition of the allocate_process() function.</p> <p>• Consider the case where the value of the variable number_of_processes is 254 at the time of the test. But due to the race condition, another process makes it 255. </p> <p>• Thus, when the process executes, the value of variable becomes 256 which is inconsistent.</p> </div>
<h2>Step-5</h2>
<div class="answer"> <p> <b>Therefore, replacing the integer variable with atomic_t will not prevent the race condition.</b> </p></div>
