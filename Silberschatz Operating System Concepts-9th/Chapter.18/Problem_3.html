<h2>Step-1</h2>
<div class="answer"> <p>2481-21-14E AID: 268</p> <p> RID: 146</p> <p> The effect does not allow paging out of kernel memory in Linux is that the non-preemptability of the kernel is preserved. Any process taking a page fault, whether in kernel or in user mode, risks being rescheduled while the required data is paged in from disk. Because the kernel can rely on not being rescheduled during access to its primary data structures, locking requirements to protect the integrity of those data structures are very greatly simplified. </p> <p>The advantages of this design is</p> <p> Simplicity in itself, </p> <p>It also provides an important performance advantage on uniprocessor machines due to the fact that it is not necessary to do additional locking on most internal data structures.</p> <p> There are a number of disadvantages to the lack of page able kernel memory, however. First of all, it imposes constraints on the amount of memory that the kernel can use. It is unreasonable to keep very large data structures in non-pageable memory, since that represents physical memory that absolutely cannot be used for anything else. This has two impacts: first of all, the kernel must prune back many of its internal data structures manually, instead of being able to rely on a single virtual memory mechanism to keep physical memory usage under control.</p> <p> Second, it makes it infeasible to implement certain features that require large amounts of virtual memory in the kernel, such as the /tmp filesystem (a fast virtual-memory-based file system found on some UNIX systems).</p> <p>Note that the complexity of managing page faults while running kernel code is not an issue here. The Linux kernel code is already able to deal with page faults: it needs to be able to deal with system calls whose arguments reference user memory that may be paged out to disk.</p></div>
