<h2>Step-1</h2>
<div class="answer"> <p> <b>The three different ways to implement threads are</b>:</p> <p> 1. Kernel-based threads</p> <p> 2. User-mode threads and</p> <p> 3. Hybrid threads</p> </div>
<h2>Step-2</h2>
<div class="answer"> <p>1. <b>Kernel-based threads</b>:</p> <p> The operating system kernel may provide support for threads itself. So, the threads may be implemented as separate processes that happen to share a common address space, or they may be implemented as separate execution contexts within a single process. Whichever way the threads are organized, they appear as fully independent execution contexts to the application.</p> </div>
<h2>Step-3</h2>
<div class="answer"> <p>The advantages of implementing Kernel-threaded systems are:</p> <p> 1. Kernel-threaded systems can take advantage of multiple processors if they are available and</p> <p> 2. If one thread blocks in a kernel service routine, </p> <p> other threads are still able to run.</p> </div>
<h2>Step-4</h2>
<div class="answer"> <p> 2. <b>User-mode threads</b>:</p> <p> User-mode thread packages rely on some kernel support—they may require timer interrupt facilities, for example—but the scheduling between threads is not performed by the kernel but by some library of user-mode code. Multiple threads in such an implementation appear to the operating system as a single execution context. When the multithreaded process is running, it decides for itself which of its threads to execute, using non-local jumps to switch between threads according to its own preemptive or non-preemptive scheduling rules.</p> </div>
<h2>Step-5</h2>
<div class="answer"> <p> However, user-mode implementations do have their own advantages. The most obvious is performance: invoking the kernel’s own scheduler to switch between threads involves entering a new protection domain as the CPU switches to kernel mode, whereas switching between threads in user mode can be achieved simply by saving and restoring the main CPU registers. User-mode threads may also consume less system memory: most UNIX systems will reserve at least a full page for a kernel stack for each kernel thread, and this stack may not be pageable.</p> </div>
<h2>Step-6</h2>
<div class="answer"> <p> 3. <b>Hybrid</b>:</p> <p> Hybrid implementations are also possible, where a large number of threads are made available to the application using a smaller number of kernel threads. Runnable user threads are run by the first available kernel thread. In Linux, threads are implemented within the kernel by a clone mechanism that creates a new process within the same virtual address space as the parent process. Unlike some kernel-based thread packages,</p> <p> The Linux kernel does not make any distinction between threads and processes: a thread is simply a process that did not create a new virtual address space when it was initialized.</p> </div>
<h2>Step-7</h2>
<div class="answer"> <p> The hybrid approach, implementing multiple user threads over a smaller number of kernel threads, allows a balance between these tradeoffs to be achieved. The kernel threads will allow multiple threads to be in blocking kernel calls at once and will permit running on multiple CPUs, and user-mode thread switching can occur within each kernel thread to perform lightweight threading without the overheads of having too many kernel threads. The downside of this approach is complexity: giving control over the tradeoff complicates the thread library’s user interface.</p></div>
