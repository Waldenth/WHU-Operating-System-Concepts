<h2>Step-1</h2>
<div class="answer"> <p>In Linux, creation of a thread involves only the creation of some very simple data structures to describe the new thread. Space must be reserved for the new thread’s execution context, its saved registers, its kernel stack page, its dynamic information such as its security profile, its signal state but no new virtual address space is created.</p> <p>Creating this new virtual address space is the most expensive part of the creation of a new process. The entire page table of the parent process must be copied, with each page being examined so that copy-on-write semantics can be achieved and so that reference counts to physical pages can be updates. The parent process’s virtual memory is also affected by the process creation: any private read/write pages owned by the parent must be marked read-only so that copy-on –write can happen.</p> <p>Scheduling of threads and processes also differs in this respect. The decision algorithm performed when deciding what process to run next is the same regardless of whether the process is a fully independent process or just a thread but the action of context switching to a separate process is much more costly than switching to a thread. A process requires that a CPU’s virtual memory control registers be updated to point to the new virtual address space’s page tables.</p> <p>In both cases-creation of a process or context switching between processes the extra virtual memory operations have a significant cost. On many CPU’s, changing page tables or swapping between page tables is not cheap; all are part of the virtual address translation look-aside buffers in the CPU must be purged when the page tables are changed. These costs are not incurred when creating or scheduling between threads.</p></div>
