<h2>Step-1</h2>
<div class="answer"> <p> <b>Communication between Processes on a Single Computer</b> </p> <p>The comparison between the use of Networking Sockets as opposed to the use of Shared Memory as a mode of communicating data between processes on a computer is shown in the table below:</p> <table border="1" style="border-collapse:collapse;"> <tr> <td> <p> <b>S. No</b> </p> </td> <td> <p> <b>Networking Sockets</b> </p> </td> <td> <p> <b>Shared Memory</b> </p> </td> </tr> <tr> <td> <p>1.</p> </td> <td> <p>Networking Socket programming interface <b>has</b> numerous <b>synchronization</b> properties.</p> </td> <td> <p>Shared memory interface <b>does</b> <b>not</b> <b>have</b> <b>synchronization</b> properties.</p> </td> </tr> <tr> <td> <p>2.</p> </td> <td> <p>Processes <b>can</b> <b>detect</b> whenever new data arrives on the network connection, how much data has arrived, and the sender’s information as well.</p> </td> <td> <p>Processes <b>cannot detect</b> if another process has sent data or made any changes to the data stored in the memory that is being shared.</p> </td> </tr> <tr> <td> <p>3.</p> </td> <td> <p>There is a provision for the <b>processes</b> to <b>block</b> themselves until new data has reached the networking socket. Processes can request for a signal to be sent when the data has been sent completely to unblock themselves.</p> </td> <td> <p>There is <b>no provision</b> for the processes to <b>block</b> themselves and request for a signal for when the data has been delivered.</p> </td> </tr> <tr> <td> <p>4.</p> </td> <td> <p>While communicating data in a networking socket, <b>data</b> is <b>copied</b> from one memory to another multiple times.</p> </td> <td> <p>Shared memory interface does not require copying of data multiple times. <b>Data</b> is just <b>updated</b> in the memory <b>once</b>, and is accessible by all processes.</p> </td> </tr> <tr> <td> <p>5.</p> </td> <td> <p>Requires a <b>service call</b> to be made by the kernel system to start the transfer of data.</p> </td> <td> <p>Data transfer can be done in user-mode <b>without</b> the kernel system making any <b>service call</b>.</p> </td> </tr> </table> </div>
<h2>Step-2</h2>
<div class="answer"> <p>The advantages of Networking Sockets are listed below:</p> <p>• <b>Data Delivery Detection</b>: This interface possesses the ability to detect whenever new data arrives, what is the size of the new data and who has sent that data.</p> <p>• <b>Blocking of Processes</b>: Processes can block themselves whilst data is being delivered. They can request for a wake up signal to unblock themselves when data has been delivered completely.</p> <p>• <b>Multiple connections</b>: Processes with a networking socket can approve more than one connection on that socket. Processes can determine when new processes are trying to make a connection as well as when the old processes terminate the connection.</p> </div>
<h2>Step-3</h2>
<div class="answer"> <p>The advantages of Shared Memory are listed below:</p> <p>• <b>Fast</b>: It is a lot faster than networking socket interface.</p> <p>• <b>No Data Copied: </b>Data is just updated once in the common memory. There is no requirement to copy data multiple times.</p> <p>• <b>No System Service Calls required: </b>Unlike in the case of Networking Sockets, communication can be done in user-mode itself, without shifting control to the kernel system to begin the transferring of data.</p> </div>
<h2>Step-4</h2>
<div class="answer"> <p>Networking Sockets are preferred over Shared Memory in cases where it is important to <b>manage connections</b> or when <b>synchronization</b> of the <b>sender</b> as well as <b>receiver</b> of the data is mandatory. <b>Servers</b> mostly make use of networking sockets to communicate with their client. A socket is set up by the server to listen to client requests. The client builds connection to the same socket to send requests to the client. In this manner, the client can detect whenever a new request is received and by whom was it sent.</p> </div>
<h2>Step-5</h2>
<div class="answer"> <p>Shared Memory is preferred over Networking Sockets when multiple <b>processes</b> need <b>access</b> to a huge size of <b>data</b>, which is <b>common</b> to all processes or when a big amount of <b>data</b> is required to be <b>transferred</b> for certain purposes, but such a large amount of data is difficult to copy multiple times. An example of this is, in offices, all <b>workstations</b> connected by a Local Area Network are connected to a shared memory, so that data does not have to be updated multiple times. It is just updated once in the common shared memory an all systems have access to the updated data.</p></div>
