<h2>Step-1</h2>
<div class="answer"> <p> <b>Scheduling</b> </p> <p>The difference between preemptive and non-preemptive scheduling is explained in the table below:</p> <table border="1" style="border-collapse:collapse;"> <tr> <td> <p> <b>S. No</b> </p> </td> <td> <p> <b>Preemptive Scheduling</b> </p> </td> <td> <p> <b>Non-Preemptive Scheduling</b> </p> </td> </tr> <tr> <td> <p>1.</p> </td> <td> <p>It interrupts a process in the middle of its execution.</p> </td> <td> <p>Once a process enters the running state, it is <b>not</b> allowed to be <b>interrupted</b> till it has completed its service time.</p> </td> </tr> <tr> <td> <p>2.</p> </td> <td> <p>It <b>takes the CPU away</b> from the process being executed and allocates it to another process with a higher priority.</p> </td> <td> <p>It makes sure that the process <b>keeps hold of the CPU</b> until it has completed its current CPU burst, thus completing its execution.</p> </td> </tr> <tr> <td> <p>3.</p> </td> <td> <p>It is <b>complex</b> to implement.</p> </td> <td> <p>It is <b>easier</b> to implement.</p> </td> </tr> <tr> <td> <p>4.</p> </td> <td> <p> <b>High overhead</b> it produced due to constant switching.</p> </td> <td> <p> <b>Lower overhead </b>due to simple implementation.</p> </td> </tr> <tr> <td> <p>5.</p> </td> <td> <p>The process switches from <b>running state</b> to <b>ready state</b> and then <b>waiting state</b> to <b>ready</b> <b>state</b>.</p> </td> <td> <p>The process switches from <b>running state</b> to <b>waiting state</b> and then the process terminates.</p> </td> </tr> <tr> <td> <p>6.</p> </td> <td> <p>It is <b>costlier</b> to implement due to being complex.</p> </td> <td> <p>It is <b>cheaper</b> to implement due to being simple.</p> </td> </tr> </table> </div>
